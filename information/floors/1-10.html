<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SBO:R Wiki – Floor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link rel="stylesheet" href="/css/floor-hud.css" />
  <link rel="stylesheet" href="/css/home-hud-skin.css">

  <link rel="icon" href="/logo.png" type="image/png" />
  <link rel="apple-touch-icon" href="/logo.png" />
</head>

<body>

  <!-- ===== HUD TOP BAR ===== -->
  <header class="hud-top">
    <div class="hud-left">
      <div class="hud-kicker">SWORD BLOX ONLINE: REBIRTH</div>
      <div class="hud-title" id="floorTitle">FLOOR ?</div>
      <div class="hud-subtitle" id="floorSubtitle">LOADING…</div>
    </div>

    <nav id="site-nav" class="hud-nav" aria-label="Site navigation"></nav>

    <div class="hud-right" id="floorTags"></div>
  </header>

  <!-- ===== MAIN GRID ===== -->
  <main class="floor-grid">

    <!-- LEFT COLUMN -->
    <aside class="col-left">

      <section class="hud-panel">
        <div class="panel-head"><span>FLOOR INFO</span></div>
        <ul class="hud-list bullets" id="floorInfo"></ul>
      </section>

      <section class="hud-panel">
        <div class="panel-head"><span>ACTIVITIES</span></div>
        <ul class="hud-list chevrons" id="floorActivities"></ul>
      </section>

      <section class="hud-panel">
        <div class="panel-head"><span>SHOPS</span></div>
        <ul class="hud-list chevrons" id="floorShops"></ul>
      </section>

    </aside>

    <!-- CENTER / MAP -->
    <section class="hud-panel panel-map">
      <div class="panel-head">
        <span>SYSTEM RECORD: FLOOR MAP</span>
        <span class="panel-chip" id="mapChip">FLOOR MAP</span>
      </div>

      <div class="map-frame">
        <div id="mapHost"></div>
      </div>

      <!-- FLOOR DATA (Lore) -->
      <div class="hud-panel subpanel">
        <div class="panel-head slim"><span>SYSTEM RECORD: FLOOR DATA</span></div>
        <div class="hud-lore" id="floorLore">LOADING…</div>
      </div>

      <!-- NEW: MOBS + BOSSES -->
      <div class="hud-panel subpanel">
        <div class="panel-head slim">
          <span>SYSTEM RECORD: MOBS & BOSSES</span>
          <span class="panel-chip" id="mobChip">ENCOUNTERS</span>
        </div>

        <div class="hud-table-wrap">
          <table class="hud-table" aria-label="Mobs and Bosses table">
            <thead>
              <tr>
                <th>TYPE</th>
                <th>NAME</th>
                <th>LEVEL</th>
                <th>LOCATION</th>
                <th>DROPS</th>
                <th>NOTES</th>
              </tr>
            </thead>
            <tbody id="mobsBossesBody">
              <tr><td colspan="6" class="hud-td-muted">LOADING…</td></tr>
            </tbody>
          </table>
        </div>
      </div>

      <!-- NEW: QUESTS -->
      <div class="hud-panel subpanel">
        <div class="panel-head slim">
          <span>SYSTEM RECORD: QUESTS</span>
          <span class="panel-chip" id="questChip">OBJECTIVES</span>
        </div>

        <div class="hud-table-wrap">
          <table class="hud-table" aria-label="Quests table">
            <thead>
              <tr>
                <th>QUEST</th>
                <th>GIVER</th>
                <th>OBJECTIVE</th>
                <th>REWARD</th>
                <th>NOTES</th>
              </tr>
            </thead>
            <tbody id="questsBody">
              <tr><td colspan="5" class="hud-td-muted">LOADING…</td></tr>
            </tbody>
          </table>
        </div>
      </div>

    </section>

  </main>

  <div class="floor-note" id="systemNoteBox" hidden>
    <div class="floor-note-title">SYSTEM NOTE</div>
    <div class="floor-note-body" id="systemNote"></div>
  </div>

<script>
  const byId = (id) => document.getElementById(id);

  function getFloorIdFromURL() {
    const params = new URLSearchParams(window.location.search);
    return params.get("id") || "1";
  }

  function li(text) {
    const el = document.createElement("li");
    el.textContent = text;
    return el;
  }

  function chip(text, soft = false) {
    const el = document.createElement("div");
    el.className = soft ? "hud-chip hud-chip-soft" : "hud-chip";
    el.textContent = text;
    return el;
  }

  function renderList(targetUl, items) {
    if (!targetUl) return;
    targetUl.innerHTML = "";
    (items || []).forEach(item => targetUl.appendChild(li(item)));
  }

  function renderLore(target, lore) {
    if (!target) return;
    target.innerHTML = "";

    if (Array.isArray(lore) && lore.length) {
      lore.forEach(line => {
        const p = document.createElement("p");
        p.textContent = line;
        target.appendChild(p);
      });
      return;
    }

    if (typeof lore === "string" && lore.trim()) {
      const p = document.createElement("p");
      p.textContent = lore.trim();
      target.appendChild(p);
      return;
    }

    target.textContent = "NO LORE DATA AVAILABLE.";
  }

  // ===== TABLE HELPERS =====

  function td(text, muted = false) {
    const cell = document.createElement("td");
    cell.textContent = (text ?? "").toString();
    if (muted) cell.className = "hud-td-muted";
    return cell;
  }

  function clearTbody(tbody) {
    if (!tbody) return;
    tbody.innerHTML = "";
  }

  function renderMobsBosses(tbody, mobs, bosses) {
    if (!tbody) return;

    const mobRows = Array.isArray(mobs) ? mobs : [];
    const bossRows = Array.isArray(bosses) ? bosses : [];

    clearTbody(tbody);

    const combined = [
      ...mobRows.map(x => ({ ...x, __type: "MOB" })),
      ...bossRows.map(x => ({ ...x, __type: "BOSS" }))
    ];

    if (!combined.length) {
      const tr = document.createElement("tr");
      tr.appendChild(td("NO ENCOUNTER DATA AVAILABLE.", true));
      tr.lastChild.colSpan = 6;
      tbody.appendChild(tr);
      return;
    }

    combined.forEach(row => {
      const tr = document.createElement("tr");
      tr.appendChild(td(row.__type || ""));
      tr.appendChild(td(row.name || ""));
      tr.appendChild(td(row.level || ""));
      tr.appendChild(td(row.location || ""));
      tr.appendChild(td(row.drops || ""));
      tr.appendChild(td(row.notes || ""));
      tbody.appendChild(tr);
    });
  }

  function renderQuests(tbody, quests) {
    if (!tbody) return;

    clearTbody(tbody);

    const rows = Array.isArray(quests) ? quests : [];

    if (!rows.length) {
      const tr = document.createElement("tr");
      tr.appendChild(td("NO QUEST DATA AVAILABLE.", true));
      tr.lastChild.colSpan = 5;
      tbody.appendChild(tr);
      return;
    }

    // Support either objects OR simple strings
    rows.forEach(q => {
      const tr = document.createElement("tr");

      if (typeof q === "string") {
        tr.appendChild(td(q));
        tr.appendChild(td(""));
        tr.appendChild(td(""));
        tr.appendChild(td(""));
        tr.appendChild(td(""));
        tbody.appendChild(tr);
        return;
      }

      tr.appendChild(td(q.name || ""));
      tr.appendChild(td(q.giver || ""));
      tr.appendChild(td(q.objective || ""));
      tr.appendChild(td(q.reward || ""));
      tr.appendChild(td(q.notes || ""));
      tbody.appendChild(tr);
    });
  }

  // ===== SAO MAP TOOLTIP SYSTEM =====

  function isTouchLike() {
    return window.matchMedia("(hover: none), (pointer: coarse)").matches;
  }

  function clamp(n, min, max) {
    return Math.max(min, Math.min(max, n));
  }

  function buildTooltip() {
    const tip = document.createElement("div");
    tip.className = "map-tooltip";
    tip.setAttribute("role", "dialog");
    tip.setAttribute("aria-live", "polite");
    tip.hidden = true;

    tip.innerHTML = `
      <div class="map-tooltip-scan" aria-hidden="true"></div>
      <div class="map-tooltip-head">
        <div class="map-tooltip-title" id="mapTipTitle">LOCATION</div>
        <button class="map-tooltip-close" type="button" aria-label="Close tooltip">✕</button>
      </div>
      <div class="map-tooltip-system" id="mapTipSystem"></div>
      <div class="map-tooltip-body" id="mapTipDesc"></div>
    `;

    return tip;
  }

  function setTooltipContent(tip, data) {
    const titleEl = tip.querySelector("#mapTipTitle");
    const sysEl = tip.querySelector("#mapTipSystem");
    const descEl = tip.querySelector("#mapTipDesc");

    titleEl.textContent = (data.label || "LOCATION").toUpperCase();
    descEl.textContent = data.desc || "NO DATA AVAILABLE.";

    const sys = (data.system || "").trim();
    if (sys) {
      sysEl.textContent = sys;
      sysEl.style.display = "";
    } else {
      sysEl.textContent = "";
      sysEl.style.display = "none";
    }

    tip.dataset.danger = (data.danger || "").toUpperCase();
  }

  function positionTooltip(tip, anchorEl, containerEl) {
    const cRect = containerEl.getBoundingClientRect();
    const aRect = anchorEl.getBoundingClientRect();
    const tRect = tip.getBoundingClientRect();

    let x = (aRect.left - cRect.left) + 14;
    let y = (aRect.top - cRect.top) - tRect.height - 12;

    if (y < 8) y = (aRect.top - cRect.top) + aRect.height + 10;

    x = clamp(x, 8, cRect.width - tRect.width - 8);
    y = clamp(y, 8, cRect.height - tRect.height - 8);

    tip.style.left = `${x}px`;
    tip.style.top = `${y}px`;
  }

  function attachInteractiveCallouts(overlay, container, callouts) {
    const tip = buildTooltip();
    container.appendChild(tip);

    let pinned = false;
    let pinnedEl = null;

    const closeBtn = tip.querySelector(".map-tooltip-close");

    function showTipFor(el, data, pin = false) {
      pinned = pin;
      pinnedEl = pin ? el : pinnedEl;

      tip.classList.toggle("pinned", pin);
      setTooltipContent(tip, data);

      tip.hidden = false;
      tip.classList.add("show");

      tip.classList.toggle("danger", (tip.dataset.danger === "WARNING"));

      if (!isTouchLike()) {
        requestAnimationFrame(() => {
          positionTooltip(tip, el, container);
        });
      }

      el.setAttribute("aria-expanded", "true");
    }

    function hideTip(force = false) {
      if (!force && pinned) return;

      pinned = false;
      pinnedEl = null;

      tip.classList.remove("show", "pinned", "danger");
      tip.hidden = true;

      overlay.querySelectorAll(".callout").forEach(btn => btn.setAttribute("aria-expanded", "false"));
    }

    closeBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      hideTip(true);
    });

    document.addEventListener("pointerdown", (e) => {
      if (tip.hidden) return;
      const inTip = tip.contains(e.target);
      const inCallout = overlay.contains(e.target);
      if (!inTip && !inCallout) hideTip(true);
    });

    (callouts || []).forEach((c) => {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "callout";
      btn.textContent = c.label || "";
      btn.setAttribute("aria-haspopup", "dialog");
      btn.setAttribute("aria-expanded", "false");

      if (c.top) btn.style.top = c.top;
      if (c.left) btn.style.left = c.left;
      if (c.right) btn.style.right = c.right;
      if (c.bottom) btn.style.bottom = c.bottom;

      btn.addEventListener("pointerenter", () => {
        if (isTouchLike()) return;
        if (pinned) return;
        showTipFor(btn, c, false);
      });

      btn.addEventListener("pointerleave", () => {
        if (isTouchLike()) return;
        if (pinned) return;
        hideTip(true);
      });

      btn.addEventListener("focus", () => {
        if (pinned) return;
        showTipFor(btn, c, false);
      });

      btn.addEventListener("blur", () => {
        if (pinned) return;
        hideTip(true);
      });

      btn.addEventListener("click", (e) => {
        e.stopPropagation();

        if (pinned && pinnedEl === btn) {
          hideTip(true);
          return;
        }

        const shouldPin = true;
        showTipFor(btn, c, shouldPin);
      });

      overlay.appendChild(btn);
    });

    window.addEventListener("resize", () => {
      if (!tip.hidden && pinned && pinnedEl && !isTouchLike()) {
        positionTooltip(tip, pinnedEl, container);
      }
    });
  }

  function renderMap(map) {
    const host = byId("mapHost");
    if (!host) return;

    host.innerHTML = "";

    const hasImage = map && map.image;

    if (hasImage) {
      const wrap = document.createElement("div");
      wrap.className = "map-image-wrap";

      const img = document.createElement("img");
      img.className = "map-img";
      img.src = map.image;
      img.alt = map.alt || "Floor map";

      const overlay = document.createElement("div");
      overlay.className = "map-overlay";

      wrap.appendChild(img);
      wrap.appendChild(overlay);
      host.appendChild(wrap);

      attachInteractiveCallouts(overlay, wrap, map.callouts);

      img.addEventListener("error", () => {
        host.innerHTML = "";
        host.appendChild(makePlaceholder(map));
      });

      return;
    }

    host.appendChild(makePlaceholder(map));
  }

  function makePlaceholder(map) {
    const placeholder = document.createElement("div");
    placeholder.className = "map-placeholder";

    const scan = document.createElement("div");
    scan.className = "scanline";
    placeholder.appendChild(scan);

    const overlay = document.createElement("div");
    overlay.className = "map-overlay";
    placeholder.appendChild(overlay);

    attachInteractiveCallouts(overlay, placeholder, map?.callouts || []);

    return placeholder;
  }

  async function init() {
    const floorId = getFloorIdFromURL();

    const res = await fetch("/data/floors10.json", { cache: "no-store" });
    if (!res.ok) {
      byId("floorSubtitle").textContent = "FAILED TO LOAD FLOORS.JSON";
      return;
    }

    const data = await res.json();
    const floor = (data.floors || []).find(f => String(f.id) === String(floorId));

    if (!floor) {
      byId("floorTitle").textContent = "FLOOR NOT FOUND";
      byId("floorSubtitle").textContent = `No entry for id=${floorId}`;
      return;
    }

    // Top HUD
    byId("floorTitle").textContent = `FLOOR ${floor.number ?? floor.id}`;
    byId("floorSubtitle").textContent = (floor.name || "UNKNOWN FLOOR").toUpperCase();

    const tagsHost = byId("floorTags");
    if (tagsHost) {
      tagsHost.innerHTML = "";
      (floor.tags || []).forEach((t, i) => tagsHost.appendChild(chip(t, i > 0)));
    }

    // Lists
    renderList(byId("floorInfo"), floor.info);
    renderList(byId("floorActivities"), floor.activities);
    renderList(byId("floorShops"), floor.shops);

    // Lore
    renderLore(byId("floorLore"), floor.lore || floor.systemNote);

    // Map
    const mapChip = byId("mapChip");
    if (mapChip) {
      mapChip.textContent = floor.name ? floor.name.toUpperCase() : "FLOOR MAP";
    }
    renderMap(floor.map);

    // NEW: Tables
    renderMobsBosses(byId("mobsBossesBody"), floor.mobs, floor.bosses);
    renderQuests(byId("questsBody"), floor.quests);

    // System note
    const noteBox = byId("systemNoteBox");
    const note = (floor.systemNote || "").trim();
    if (noteBox) {
      if (note) {
        byId("systemNote").textContent = note;
        noteBox.hidden = false;
      } else {
        noteBox.hidden = true;
      }
    }

    // Update page title
    document.title = `SBO:R Wiki – Floor ${floor.number ?? floor.id}`;
  }

  init();
</script>

  <script src="/js/navbar.js?v=1"></script>
</body>
</html>
